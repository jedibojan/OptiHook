# File Structure

This document describes the file and folder structure for a smart contract project built using Foundry. The structure is designed to organize smart contracts, tests, scripts, libraries, and compilation artifacts efficiently, following Foundry conventions and enhancing project maintainability.

## Root Directory

The root directory serves as the foundation of the project, containing key folders and configuration files necessary for development, testing, and deployment.

### Folders

- **`src/`**: Contains all smart contract source files written in Solidity.
  - Example: `Counter.sol`

- **`test/`**: Contains test files for the smart contracts, adhering to the Foundry naming convention where each test file corresponds to a smart contract (e.g., `Counter.t.sol` for `Counter.sol`).
  - Example: `Counter.t.sol`

- **`script/`**: Holds deployment and auxiliary scripts (e.g., a time travel script), named with a numeric prefix for execution order and clarity (e.g., `01_Counter.s.sol`), following the Foundry convention of `*.s.sol`.
  - Example: `01_Counter.s.sol`

- **`lib/`**: Stores external smart contract libraries used in the project, such as `v4-periphery`, `forge-std`, and others.
  - Examples: `v4-periphery/`, `forge-std/`

- **`out/`**: Contains JSON artifacts of compiled smart contracts, generated by the `forge build` command.
  - Example: `Counter.json`

### Configuration Files

- **`foundry.toml`**: Foundry configuration file specifying settings like compiler version, optimization flags, and test parameters.
- **`README.md`**: Project overview, including setup instructions and usage guidelines.
- **`.gitignore`**: Lists files and directories (e.g., build artifacts) to be excluded from Git version control.

## Detailed Structure

Here’s a closer look at the purpose and contents of each key folder:

### `src/`

- **Purpose**: Houses all smart contract source code.
- **Naming**: Each smart contract is typically in its own file, named after the contract (e.g., `Counter.sol`).
- **Role**: Centralizes the protocol’s logic for easy management and updates.

### `test/`

- **Purpose**: Contains test files to verify the functionality of smart contracts.
- **Naming Convention**: Follows Foundry’s standard where each test file is named `<ContractName>.t.sol` (e.g., `Counter.t.sol` for `Counter.sol`).
- **Structure**: Mirrors the `src/` folder, ensuring every contract has a corresponding test.

### `script/`

- **Purpose**: Includes scripts for deployment and auxiliary tasks (e.g., time travel operations).
- **Naming Convention**: Files follow the `*.s.sol` pattern with a numeric prefix (e.g., `01_Counter.s.sol`) to indicate execution order and improve visibility.
- **Examples**:
  - `01_Counter.s.sol`: Deploys the `Counter` contract.
  - `02_TimeTravel.s.sol`: Auxiliary script for time manipulation in testing or deployment.

### `lib/`

- **Purpose**: Stores external libraries and dependencies required by the project.
- **Structure**: Each library resides in its own subdirectory, often managed via Git submodules or Foundry’s dependency tools.
- **Examples**:
  - `v4-periphery/`: Uniswap V4 periphery contracts for integration.
  - `forge-std/`: Foundry’s standard library for testing utilities.

### `out/`

- **Purpose**: Holds compilation outputs generated by the `forge build` command.
- **Contents**: JSON files containing ABI, bytecode, and other artifacts for each compiled contract (e.g., `Counter.json`).
- **Note**: This folder is automatically created and updated during the build process.

## Overview

This file structure provides a clear separation of concerns:
- Smart contracts in `src/` are easy to locate and modify.
- Tests in `test/` ensure comprehensive verification with a consistent naming convention.
- Scripts in `script/` are organized for sequential execution, enhancing deployment workflows.
- Libraries in `lib/` keep dependencies isolated and manageable.
- Artifacts in `out/` provide ready access to compiled outputs for deployment and interaction.

By adhering to Foundry’s conventions and using numeric prefixes for scripts, this structure supports scalability and simplifies collaboration among developers.